<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<style type="text/css">
	.outer{
		fill:transparent;
		stroke:black;
	}

	.inner{
		fill:black;
		stroke:transparent;
	}

	.edge{
		stroke-width:6px;
		stroke-linejoin:round;
		stroke-linecap: round;
		stroke:#6ECDF5;
		opacity: 1;
	}

	.hedge{
		stroke-width:6px;
		stroke-linejoin:round;
		stroke-linecap: round;
		stroke:#E60433;
		opacity: 1;
	}

	path, circle, .outer{
		display: none;
	}

	#logo{
		margin:200px 0 0 200px;
		float:left;
	}

	#logo-text{
		margin:250px 0 0 50px;
		float:left;
	}
</style>
</head>
<body>
	<div id="logo"></div><div id="logo-text"><img src="assets/Logo-Text@2x.png" alt="" /></div>
<script src="./libs/d3.min.js"></script>
<script type="text/javascript">

var boundaryRad = 100, boundaryRadSquare = boundaryRad*boundaryRad, padding = 20;

var svg = d3.select('#logo').append('svg').attr('width',(boundaryRad+padding)*2).attr('height',(boundaryRad+padding)*2).append('g').attr('transform','translate('+(boundaryRad+padding)+','+(boundaryRad+padding)+')');

svg.append('circle').attr('r',boundaryRad).attr('class','outer');

function randVelo(){
	var base = 1 + Math.random();
	if(Math.random()>0.5){
		base *= -1;
	}
	return base * 1;
}

function resize(n){
	return n/250*boundaryRad;
}

var points = [
	{x:resize(-236),y:resize(33),velX:randVelo(),velY:randVelo(),hist:[]},
	{x:resize(-195),y:resize(154),velX:randVelo(),velY:randVelo(),hist:[]},
	{x:resize(145),y:resize(-200),velX:randVelo(),velY:randVelo(),hist:[]},
	{x:resize(199),y:resize(104),velX:randVelo(),velY:randVelo(),hist:[]},
	{x:resize(244),y:resize(7),velX:randVelo(),velY:randVelo(),hist:[]},
	{x:resize(-142),y:resize(-163),velX:randVelo(),velY:randVelo(),hist:[]}
];

/*for(var i = 0; i<50; i++){
	points.push({x:(Math.random()-0.5)*200,y:(Math.random()-0.5)*200,velX:(Math.random()-0.5)*5,velY:(Math.random()-0.5)*5});
}*/

var edges = [
	[0,1],
	[1,2],
	[0,2],

	[0,3],
	[2,3],

	[3,4],
	[4,5],
	[0,5]
];

var planes = [
	{nodes:[0,1,2],color:'rgba(255,0,0,0.8)'},
	{nodes:[0,2,3],color:'rgba(46,145,209,0.8)'},
	{nodes:[0,3,4,5],color:'rgba(46,145,209,0.8)'}
];

var paths = svg.append('g').selectAll('path').data(planes).enter().append('path').attr('class','plane').style('fill',function(d){ return d.color; });
var lines = svg.append('g').selectAll('line').data(edges).enter().append('line').attr('class','edge');
var histLines = svg.append('g').selectAll('line').data(edges).enter().append('line').attr('class','hedge');
var circles = svg.append('g').selectAll('circle').data(points).enter().append('circle').attr('class','inner').attr('r',3);

var velocity = d3.scaleLinear().domain([0,1]).range([2,0.3]);

function step() {

	points.forEach(function(p){

		var radSquare= p.x*p.x + p.y*p.y;

		//update
		var lastX = p.x;
		var lastY = p.y;

		p.x += p.velX*velocity(radSquare/boundaryRadSquare);
		p.y += p.velY*velocity(radSquare/boundaryRadSquare);

		p.hist.push({x:p.x,y:p.y});
		if(p.hist.length > 5){
			p.hist.splice(0,1);
		}
		
		//boundary
		if (radSquare > boundaryRadSquare) {
			
			//find intersection point with circle. simple method: midpoint
			var exitX = (lastX + p.x)/2;
			var exitY = (lastY + p.y)/2;
			
			//scale to proper radius
			var exitRad = Math.sqrt(exitX*exitX + exitY*exitY);
			exitX *= boundaryRad/exitRad;
			exitY *= boundaryRad/exitRad;
			
			p.x = exitX;
			p.y = exitY;

			//bounce
			var twiceProjFactor = 2*(exitX*p.velX + exitY*p.velY)/boundaryRadSquare;
			var vx = p.velX - twiceProjFactor*exitX;
			var vy = p.velY - twiceProjFactor*exitY;
			p.velX = vx;
			p.velY = vy;
		}
		
	});

	circles.data(points)
		.attr('cx', function(d){return d.x;})
		.attr('cy', function(d){return d.y;});

	lines
		.attr('x1',function(d){ return points[d[0]].x; })
		.attr('x2',function(d){ return points[d[1]].x; })
		.attr('y1',function(d){ return points[d[0]].y; })
		.attr('y2',function(d){ return points[d[1]].y; });

	histLines
		.attr('x1',function(d){ return points[d[0]].hist[0].x; })
		.attr('x2',function(d){ return points[d[1]].hist[0].x; })
		.attr('y1',function(d){ return points[d[0]].hist[0].y; })
		.attr('y2',function(d){ return points[d[1]].hist[0].y; });

	paths
		.attr('d', function(d){
			var str = '';
			d.nodes.forEach(function(p, pi){
				if(pi===0){ str += 'M'; }else{ str += 'L'; }
				str += points[p].x + ' ' + points[p].y;
			});
			return str+'Z';
		});

	window.requestAnimationFrame(step);
}

window.requestAnimationFrame(step);

</script>
</body>
</html>
